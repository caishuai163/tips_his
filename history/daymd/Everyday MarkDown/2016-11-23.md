# 账户安全
1. 数据库中密码存储安全性  
    1. 明文存储。  
      + 直接存储。  
      + 明文转换后存储。  
      + 对称加密算法。  
      + 非对称加密算法。    

      对于前两者而言，安全性非常低。第三种在获取到秘钥的情况下一样会被破解。最后一种相对于前三者要好一些，但当私钥被获取，依旧不安全。  
    2. 密码加密（实际上进行的是摘要算法）  
        对于MD5 sha-1等摘要算法，由于算法的不可逆性，被破解的几率会减小很多。但依旧可以通过数据库（“彩虹表”）对比来匹配出密码。    
        相对于摘要算法，多采取在进行修改的时候在数据库随机生成一个salt，将MD5后的密码+salt再去取MD5进行存储。这样对于对照“彩虹表”来对撞库来说，相对几率减小很多。但是还是可以通过穷举来解决。  
        对于上面的再进行改进。可以使用“streching”来增加摘要算法迭代的次数，或者bctype来配置摘要算法迭代的执行时间来实现加密。
        bctype：通过salt和cost值来减缓加密的过程。但对于时间及服务器占用比较高。一般为百ms级，而MD5仅仅1ms左右。  

  对于密码的加密，越复杂的对时间和服务器占用越高。

2. 密码传输  
    http而言，是明文传输，不是很安全。大多数都是对传输的内容进行加密。对于秘钥，最好每次服务器都随机生成一个秘钥，进行加密传输。但这种情况下，还是会有能被截取，进行重放攻击。  
    重放攻击的防止：  
      1. 用户请求服务器。
      2. 服务器发送一个nonce随机数。
      3. 客户端在收到请求后，将请求与信息分别进行加密，并生成一个cnonce和nc（递增的），再进行加密，将其发送给服务器。
      4. 服务器判定nonce是否过期，和nc是否是比上一次的大（即是不是过期的请求）。
      5. 正常的情况下，返回200，否则返回401

  https是加密传输。在确保ssl协议和私钥安全的情况下，是比http安全的很多。随机秘钥对密码变换后传输。  
  但是，对于服务器的要求高，影响速度。对于一些比较重要的信息，还是要走https。

# session、cookie  
cookie：客户端。session：服务器端。  
cookie：如果不设置过期时间，关闭浏览器窗口，cookie消失。这种被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。  
如果设置了过期时间，浏览器就会把cookie保存到硬盘上，直到超过设定的过期时间。  
cookie为文件，服务器只能去读取文件，而不能从其中直接获取对象，不能getcookies().  

对于登陆状态的保存，往往会采用cookie+缓存的方法。  
login()生成一个GUID，将其存入cookie，并将信息以键值对的方式存入缓存（memcache），在login校验的时候，让其验证走memcache，以cookie的GUID为key去查memcache中对应的value值，将value反序列化为对象。  
# 缓存  
+ 最刚开始的时候，一个系统有一个DB和一个服务器。
+ 业务量增大，不断的升级DB和服务器，优化表结构，直到超出承受成本。
+ 开始用缓存来应对突发的请求，分担数据库压力。  
客户端缓存，前端页面缓存，页面片段缓存ESI，应用服务器本地缓存。
+ 服务器增多，对服务器进行集群和负载均衡。  
这将产生Session的问题。首先，某服务器宕机，上面session丢失。然后就要做session复制，浪费服务器内存。cookie存储的信息太多，传来传去浪费带宽。之后要在服务器上面加上session处理器。
+ 数据库性能下降，读写分离，加缓存存数据，分布式文件系统，数据库分库，数据库分片。
现在的缓存往往都是采用访问较快的NoSQL类的数据库。去处理session持久化，缓存数据库数据，减少数据库的压力。同时还能避免服务器宕机导致用户状态的丢失。  


1. 缓存穿透  
正常是client请求到memcache，memcache有则返回，没有去调数据库，调出后返回给client和存入memcache。  
但当请求真的不存在于memcache和DB时，有人不断地请求，则会造成不存在的key进行攻击。
此时，可以给不存在的值一个预设值，存入memcache，防止再次去请求Db。  
2. 缓存并发  
在memcache请求db时，由于db更新到memcache不及时，导致下次请求的时候，memcache还会去请求db。  
可以给从memcache到db的请求加一个lock，在上一个请求没有返回时，其余相同请求等在memcache外。  
3. 缓存失效  
设置同样的失效时间，会导致大量的请求同时消失，memcache剩余了大量的空间，可以给失效时间加一个上下浮动的数值。

# 缓存规则  
+ 缓存适合存储临时数据，比如访问量特别大的，不是实时性的文件，对于特别重要的数据，不适合存储在缓存中。  
+ 对于不经常改变的图片/页面启用缓存。
+ 对于定期更新的内容通过指定max-age或过期时间实现缓存。
+ Cookie能不用就不用：Cookie难以被缓存，且大多情境下是没有必要的。如果你非得使用Cookie，建议用在动态页面上。
+ 减少SSL的使用：因为共享缓存不能存储认证页面，只在必要的时候使用，并且在SSL页面上减少图片的使用。
