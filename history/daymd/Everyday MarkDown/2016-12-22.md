今天一天主要是在写单元测试，主要遇到的问题是在Mock的时候，之前我说了一个关于mock里面自定义匹配的事情，那个现在在使用时好像有些问题。  
上次提到的：  
>上面说到参数任意值，正常的是给了各种类型，anyString（），anyInt（）等，但是只是有基本的类型，对于自定义的对象却没有，然后问题来了，解决any自定义类型参数。  
>>  `Mockito.argThat(new IsPage())`这个来模拟自定义类型，其中`new IsPage()`是要自己去定义的。   
 ```
 class IsPage extends ArgumentMatcher<WanwdManhuaPage>{
		@Override
		public boolean matches(Object argument) {
			if (argument.getClass()==WanwdManhuaPage.class) {
				return true;
			}
			return false;
		}
	}
 ```  
继承`ArgumentMatcher`类，重写matches方法,判定参数的类型是不是自己的自定义类型。  


问题产生：
```
//第一个方法时去使用
when(manHuaBrowseBLL.selectCollectionStatus(Mockito.argThat(new IsPage()))).thenReturn(collectionStatus);

//在另一个方法中也去使用这个
when(manHuaBrowseBLL.selectCollectionStatus(Mockito.argThat(new IsPage()))).thenReturn(collectionStatus);
```
在这种情况下，同时运行两个单元测试方法，其中一个会报空指针异常，时候在第二次去匹配时，传入的对象变成了null  
```
class IsPage extends ArgumentMatcher<WanwdManhuaPage>{
   @Override
   public boolean matches(Object argument) {//第二次执行到这里的时候，argument变成了null
     if (argument.getClass()==WanwdManhuaPage.class) {
       return true;
     }
     return false;
   }
 }
```
在这里的argThat()虽然能够自定义匹配，但是在使用`when().then()`的时候，多次对同一个目标进行`when()`时，会只去匹配第一次的`when()`,类似于一次注入之后就不会去改变了,看薄振成给我发过来的类似问题解释，我感觉是这样的。但是我还是搞不懂为什么是null。  
最终是用`any(WanwdManhuaPage.class)`这种方式实现功能的。
