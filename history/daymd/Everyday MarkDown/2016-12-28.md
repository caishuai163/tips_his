今天主要工作上没有什么进展，基本上这个迭代的我的部分已经做完了。  
今天我主要是去学习了一下memcache以及XMemcached。
对之前教我的memcache分布式形成一个“环”，有了更进一步的理解。  
1. memcache本身不具备分布式的功能，是通过一个类似于“控制器”的组件，来生成规则，判定数据在哪个memcache上存储。  
  1. 对于取模的规则，确实是一旦添加memcache，取模的规则就变了，会造成数据的浪费。我算了一下，应该是n/最小公倍数(n+x)个数据可以被保留，其余的数据都会被浪费掉。  
  2. 采取“环”的方式，是将所有的memcache放到一个x个位置的环上，然后对存储的key进行处理，也处理成x个种类，然后按照顺序向后去找最近的memcache节点，存储到该节点上。这样的话，当插入一个memcache节点时，被浪费的也就只有这个节点和下一个节点之间的数据被浪费掉。  
  ![ring](http://git.gyyx.cn/caishuai/static/raw/7e5af7e6a569bbe55f17e3c3dde23c32e12b3f10/img/memcache.png)   
感觉memcache和redis不太一样，memcache完全是一个缓存，不具备任何的保存数据的能力；而redis则能够保存数据。感觉redis会不会在作为缓存的时候，没有memcache的效率高？因为我感觉存储数据就像是浪费了一部分能力，应该和memcache完全作为缓存而言要差上一点吧。当然memcache容灾性很不好，这点肯定不如redis.  

2. XMemcached是memcache java客户端之一。上一部分写了印象特别深的，这部分我也不知道哪部分印象特别的深。  
  1. 了解了Xmemcached如何去连接memcache，包括基本的连接和spring配置权重的连接方式。  
  2. 了解了CAS操作，通过cas协议实现原子更新，compare and set，原理类似乐观锁，每次请求存储某个数据同时要附带一个cas值，memcached比对这个cas值与当前存储数据的cas值是否相等，如果相等就让新的数据覆盖老的数据，如果不相等就认为更新失败。感觉这个可以用在并发处理上。虽说我还没有实际操作过。（我会去实际操作的）。
