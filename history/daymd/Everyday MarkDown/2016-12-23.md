今天一天还是很轻松的，或许是这周开始的时候做的太急了吧，一开始就晚上在这把之前的忙完了。  
今天主要：  
1. 是对之前的代码进行整理，看了昨天群发的关于Log的写法规范，修改了代码里面的log。  
2. 把之前我和您提过的数据库分片的join查询丢数据的事我也去尝试了，确实是丢，但是那个使用文档里面已经写了会产生这种问题以及解决方案。我相信咱们公司里面应该是不会有这种问题的。  
> 环境：用Mycat对数据库进行的集群，配了两个数据库，数据库里面有的两张表都是分片的。
  表：user(id,username), userinfo(id,uid,info)   为了配置简单，我都是对主键取模分片的
  ```
  id   uid   info
  2     3	   23
  4     2	   42
  1     4	   12
  3     2	   34
  ```
```
id  username
2	2NAME
4	4NAME
1	1NAME
3	3NAME
```
语句：`SELECT * FROM info JOIN user ON info.uid= user.id`
结果：
```
id  uid info  id1 username
4	2	42	2	2NAME
```
很明显，只查出了在同一个库中join的数据。  
在mycat的文档中，有写到对于该问题的处理(应该是使用方法吧)。  
通过 catlet 支持跨分片复杂 SQL 实现以及存储过程支持等。使用方式主要途过 mycat 注释的方式来执行，如下：  
  跨分片联合查询注解支持：
```
/*!mycat:catlet=demo.catlets.ShareJoin / select bu.,sg.* from base_user bu,sam_glucose sg where
bu.id_=sg.user_id；
注：sam_glucose 是跨分片表；
```   
在前面加上`/*!mycat:catlet=demo.catlets.ShareJoin /`的注解就可以解决这个问题。  
语句：`/*!mycat:catlet=demo.catlets.ShareJoin */SELECT * FROM info JOIN user ON info.uid= user.id`  
结果：  
```
id  uid info  id1 username
2	3	23	3	3NAME
3	2	34	2	2NAME
4	2	42	2	2NAME
1	4	12	4	4NAME
```

总而言之，还是没有去看文档，上面很多东西都是很有用的…（^……^）
